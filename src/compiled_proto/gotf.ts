/* eslint-disable */
import _m0 from "protobufjs/minimal.js";

export const protobufPackage = "gotf";

/**
 * Must is used to set terraform block attribute's required, optional or computed
 * values
 */
export enum MustBe {
  /** Computed - field will be computed by provider, user can't set it in terraform script (default). */
  Computed = 0,
  /** Optional - field is optional, user can set it in terraform script. */
  Optional = 1,
  /** OptionalAndComputed - field is optional, but will be computed or overriden by provider. */
  OptionalAndComputed = 2,
  /** Required - field is required, user must set it in terraform script. */
  Required = 3,
  UNRECOGNIZED = -1,
}

export function mustBeFromJSON(object: any): MustBe {
  switch (object) {
    case 0:
    case "Computed":
      return MustBe.Computed;
    case 1:
    case "Optional":
      return MustBe.Optional;
    case 2:
    case "OptionalAndComputed":
      return MustBe.OptionalAndComputed;
    case 3:
    case "Required":
      return MustBe.Required;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MustBe.UNRECOGNIZED;
  }
}

export function mustBeToJSON(object: MustBe): string {
  switch (object) {
    case MustBe.Computed:
      return "Computed";
    case MustBe.Optional:
      return "Optional";
    case MustBe.OptionalAndComputed:
      return "OptionalAndComputed";
    case MustBe.Required:
      return "Required";
    case MustBe.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * GoIdentity to indicate user defined go types such as structs, interfaces, etc.
 * for terraform provider and block attribute type.
 */
export interface GoIdentity {
  /** name of the user defined go type. */
  name: string;
  /**
   * import_path (go mod name) of the user defined go type.
   * defaults to current proto files go_package name.
   */
  importPath: string;
  /**
   * if set to true, this type will be generated as pointer type.
   * *should not be set for interfaces.*
   */
  ptr: boolean;
}

/** Block allows to generate terraform resource or datasource from proto message */
export interface Block {
  /**
   * name for terraform resource or datasource, defaults to message name.
   * defaults to snake_case of message name.
   */
  name?:
    | string
    | undefined;
  /**
   * explicit_fields if set to `false` (default), all fields will be generated as
   * attributes in this terraform block.
   *
   * If set to `true`, only fields with `gotf.Attribute` will be generated
   * as an attributes in this terraform block.
   *
   * Check gotf.Attribute for default attribute properties.
   */
  explicitFields: boolean;
  /**
   * client (names) used by this block. Generated terraform go code expects these
   * clients to be generated by grpc in same go_package as other protobufs.
   * Should be complete go type name
   *
   * This calls exec with `Set<ClientName>(client)`
   * The provider exec needs to implement github.com/travix/gotf/prvdr.CanConfigureGrpc interface.
   */
  client: string[];
  /** description is used to set terraform block's description. */
  description: string;
}

/** Attribute to set kind properties of terraform attribute & schema for terraform block. */
export interface Attribute {
  /** skip this field from from this terraform block. */
  skip: boolean;
  /**
   * attribute must_be computed, optional, required or optional and computed.
   *
   * If attribute is optional and `optional` keyword is not set on the fields gotf
   * will try to generate default for field such as
   *  string -> ""
   *  int32 -> 0
   *  int64 -> 0
   *  float -> 0.0
   *  bool -> false
   *
   * If you want to receive nil value set `optional` keyword on field.
   */
  mustBe: MustBe;
  /**
   * name of terraform attribute, check [attribute-names] documentation for more details.
   * defaults to snake_case of message field name.
   *
   * [attribute-names]: https://developer.hashicorp.com/terraform/plugin/best-practices/naming#attribute-names
   */
  name?:
    | string
    | undefined;
  /** sensitive if set to true field will be marked as sensitive. */
  sensitive?:
    | boolean
    | undefined;
  /**
   * description is used to set terraform attribute's description. Defaults to
   * field comment.
   */
  description?:
    | string
    | undefined;
  /**
   * md_description is used to set terraform attribute's markdown description of
   * field. Defaults to field comment.
   */
  mdDescription?:
    | string
    | undefined;
  /** deprecation is used to set terraform attribute's deprecation message. */
  deprecation?: string | undefined;
}

/** Option to create provider for this package. */
export interface Provider {
  /**
   * name is used to set terraform provider type name, all resources and datasources
   * will be generated under this provider.
   *
   * Example:
   *   name = "xyz";
   * This will produce terraform blocks will be
   *   resource "xyz_resource_name" { ... }
   *   data "xyz_datasource_name" { ... }
   */
  name: string;
  /**
   * package where generated terraform go code should be placed
   *
   * If not set files will be placed in providerpb package.
   */
  providerPackage: string;
  /** description is used to set terraform provider's description. */
  description: string;
  /**
   * exec_package use generate go scaffold for executors.
   * if this option is set, gotf will generate scaffold for block executors.
   * if the file already exists, it will be skipped.
   * it should not be same as provider_package.
   */
  execPackage?: string | undefined;
}

function createBaseGoIdentity(): GoIdentity {
  return { name: "", importPath: "", ptr: false };
}

export const GoIdentity = {
  encode(message: GoIdentity, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.importPath !== "") {
      writer.uint32(18).string(message.importPath);
    }
    if (message.ptr === true) {
      writer.uint32(24).bool(message.ptr);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GoIdentity {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.importPath = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ptr = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoIdentity {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      importPath: isSet(object.importPath) ? globalThis.String(object.importPath) : "",
      ptr: isSet(object.ptr) ? globalThis.Boolean(object.ptr) : false,
    };
  },

  toJSON(message: GoIdentity): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.importPath !== "") {
      obj.importPath = message.importPath;
    }
    if (message.ptr === true) {
      obj.ptr = message.ptr;
    }
    return obj;
  },

  create(base?: DeepPartial<GoIdentity>): GoIdentity {
    return GoIdentity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GoIdentity>): GoIdentity {
    const message = createBaseGoIdentity();
    message.name = object.name ?? "";
    message.importPath = object.importPath ?? "";
    message.ptr = object.ptr ?? false;
    return message;
  },
};

function createBaseBlock(): Block {
  return { name: undefined, explicitFields: false, client: [], description: "" };
}

export const Block = {
  encode(message: Block, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.explicitFields === true) {
      writer.uint32(16).bool(message.explicitFields);
    }
    for (const v of message.client) {
      writer.uint32(26).string(v!);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Block {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.explicitFields = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.client.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Block {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      explicitFields: isSet(object.explicitFields) ? globalThis.Boolean(object.explicitFields) : false,
      client: globalThis.Array.isArray(object?.client) ? object.client.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: Block): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.explicitFields === true) {
      obj.explicitFields = message.explicitFields;
    }
    if (message.client?.length) {
      obj.client = message.client;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<Block>): Block {
    return Block.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Block>): Block {
    const message = createBaseBlock();
    message.name = object.name ?? undefined;
    message.explicitFields = object.explicitFields ?? false;
    message.client = object.client?.map((e) => e) || [];
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseAttribute(): Attribute {
  return {
    skip: false,
    mustBe: 0,
    name: undefined,
    sensitive: undefined,
    description: undefined,
    mdDescription: undefined,
    deprecation: undefined,
  };
}

export const Attribute = {
  encode(message: Attribute, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.skip === true) {
      writer.uint32(8).bool(message.skip);
    }
    if (message.mustBe !== 0) {
      writer.uint32(16).int32(message.mustBe);
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    if (message.sensitive !== undefined) {
      writer.uint32(32).bool(message.sensitive);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.mdDescription !== undefined) {
      writer.uint32(50).string(message.mdDescription);
    }
    if (message.deprecation !== undefined) {
      writer.uint32(58).string(message.deprecation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Attribute {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.skip = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.mustBe = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sensitive = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.mdDescription = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.deprecation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Attribute {
    return {
      skip: isSet(object.skip) ? globalThis.Boolean(object.skip) : false,
      mustBe: isSet(object.mustBe) ? mustBeFromJSON(object.mustBe) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      sensitive: isSet(object.sensitive) ? globalThis.Boolean(object.sensitive) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      mdDescription: isSet(object.mdDescription) ? globalThis.String(object.mdDescription) : undefined,
      deprecation: isSet(object.deprecation) ? globalThis.String(object.deprecation) : undefined,
    };
  },

  toJSON(message: Attribute): unknown {
    const obj: any = {};
    if (message.skip === true) {
      obj.skip = message.skip;
    }
    if (message.mustBe !== 0) {
      obj.mustBe = mustBeToJSON(message.mustBe);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.sensitive !== undefined) {
      obj.sensitive = message.sensitive;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.mdDescription !== undefined) {
      obj.mdDescription = message.mdDescription;
    }
    if (message.deprecation !== undefined) {
      obj.deprecation = message.deprecation;
    }
    return obj;
  },

  create(base?: DeepPartial<Attribute>): Attribute {
    return Attribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Attribute>): Attribute {
    const message = createBaseAttribute();
    message.skip = object.skip ?? false;
    message.mustBe = object.mustBe ?? 0;
    message.name = object.name ?? undefined;
    message.sensitive = object.sensitive ?? undefined;
    message.description = object.description ?? undefined;
    message.mdDescription = object.mdDescription ?? undefined;
    message.deprecation = object.deprecation ?? undefined;
    return message;
  },
};

function createBaseProvider(): Provider {
  return { name: "", providerPackage: "", description: "", execPackage: undefined };
}

export const Provider = {
  encode(message: Provider, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.providerPackage !== "") {
      writer.uint32(18).string(message.providerPackage);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.execPackage !== undefined) {
      writer.uint32(34).string(message.execPackage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Provider {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.providerPackage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.execPackage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Provider {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      providerPackage: isSet(object.providerPackage) ? globalThis.String(object.providerPackage) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      execPackage: isSet(object.execPackage) ? globalThis.String(object.execPackage) : undefined,
    };
  },

  toJSON(message: Provider): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.providerPackage !== "") {
      obj.providerPackage = message.providerPackage;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.execPackage !== undefined) {
      obj.execPackage = message.execPackage;
    }
    return obj;
  },

  create(base?: DeepPartial<Provider>): Provider {
    return Provider.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Provider>): Provider {
    const message = createBaseProvider();
    message.name = object.name ?? "";
    message.providerPackage = object.providerPackage ?? "";
    message.description = object.description ?? "";
    message.execPackage = object.execPackage ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
